---
title: Validation
sidebar_position: 5
---

# Validation

Strux provides a flexible, rule-based validation system that can be used **standalone** or **integrated with Forms**.

:::info
The same validation engine powers both manual validation and form validation, ensuring consistent behavior across your application.
:::

---

## Overview

The validation system allows you to:

- Validate raw request data manually
- Apply rules using strings or rule objects
- Customize error messages per rule
- Define custom validation logic
- Reuse rules across controllers and forms

---

## Using the Validator

You can manually instantiate the `Validator` service inside your controllers.

```php
use Strux\Component\Validation\Validator;
use Strux\Component\Validation\Rules\Required;
use Strux\Component\Validation\Rules\Email;

$validator = new Validator($request->all());

$validator->add('email', [
    'required',               // String syntax
    new Email('Invalid!')     // Object syntax with custom message
]);

if ($validator->isValid()) {
    // Proceed...
} else {
    $errors = $validator->getErrors();
}
````

---

## Validation Rules Reference

Rules may be defined using:

* **String syntax** (e.g. `'minLength:5'`)
* **Object syntax** (e.g. `new MinLength(5)`)

| Rule         | String Syntax       | Object Syntax         | Description                   |
| ------------ | ------------------- | --------------------- | ----------------------------- |
| Alpha        | `'alpha'`           | `new Alpha()`         | Alphabetic characters only    |
| Alphanumeric | `'alphanumeric'`    | `new Alphanumeric()`  | Letters and numbers only      |
| Confirmed    | `'confirmed'`       | `new Confirmed()`     | Matches `_confirmation` field |
| Date         | `'date'`            | `new Date()`          | Valid date string             |
| Email        | `'email'`           | `new Email()`         | Valid email format            |
| Equal        | `'equal:val'`       | `new Equal('val')`    | Matches a specific value      |
| In           | `'in:a,b,c'`        | `new In('a','b')`     | One of the allowed values     |
| Integer      | `'integer'`         | `new Integer()`       | Valid integer                 |
| MaxLength    | `'maxLength:10'`    | `new MaxLength(10)`   | Maximum string length         |
| MinLength    | `'minLength:5'`     | `new MinLength(5)`    | Minimum string length         |
| NotIn        | `'notIn:a,b'`       | `new NotIn('a','b')`  | Must NOT be one of the values |
| Numeric      | `'numeric'`         | `new Numeric()`       | Numeric values only           |
| Password     | `'password'`        | `new Password()`      | Strong password validation    |
| Regex        | `'regex:/pattern/'` | `new Regex('/patt/')` | Regular expression match      |
| Required     | `'required'`        | `new Required()`      | Cannot be empty or null       |
| Same         | `'same:other'`      | `new Same('other')`   | Matches another field         |
| Url          | `'url'`             | `new Url()`           | Valid URL format              |

---

## Custom Validation

You may define custom validation logic using **Closures** (anonymous functions).

:::warning Limitation
Closures **cannot be used inside PHP attributes**.
They must be added via the `Validator` or the formâ€™s `build()` method.
:::

```php
// Inside Form::build()
$this->add('username', 'text', [
    'rules' => [
        'required',
        function ($value, $data) {
            if ($value === 'admin') {
                return 'The username "admin" is reserved.';
            }

            return true; // Valid
        }
    ]
]);
```

---

## Custom Error Messages

Custom error messages are best defined using **object-based rules**.

```php
#[StringField(rules: [
    new Required('Hey! We really need your email.'),
    new Email('This does not look like a valid email address.')
])]
protected string $email;
```

:::tip Recommended
Use object syntax for clarity, reusability, and full control over messaging.
:::

Some string rules may support message parameters depending on implementation, but object rules are preferred.

---

## Summary

* Validation can be used **with or without Forms**
* Rules support **string and object syntax**
* Object rules enable custom messages and configuration
* Closures allow advanced validation logic
* The same system powers all Strux validation

Next, explore how Validation integrates directly with **Forms** to create fully self-validating user input flows.