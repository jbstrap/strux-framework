---
title: Dependency Injection
slug: /dependency-injection
description: Mastering the Service Container and Dependency Injection in Strux.
---

# Dependency Injection

Strux is built around a powerful, **zero-configuration Dependency Injection (DI) container**.  
It automatically manages your application’s class dependencies, allowing you to write **clean, testable, and loosely coupled** code.

---

## The Concept

Dependency Injection sounds complex, but the core idea is simple:

> **Don’t create objects inside your classes — ask for them instead.**

### ❌ Bad (Tightly Coupled)

```php
class UserController
{
    public function index()
    {
        $db = new DatabaseConnection(); // Tightly coupled
        $db->query('...');
    }
}
````

### ✅ Good (Injected Dependency)

```php
class UserController
{
    public function __construct(
        protected DatabaseConnection $db
    ) {}

    public function index()
    {
        $this->db->query('...');
    }
}
```

---

## Auto-Wiring

Strux uses **PHP Reflection** to inspect constructor and method type hints.

If the container sees a class type (e.g. `UserService`), it will:

1. Attempt to automatically instantiate it
2. Resolve its dependencies recursively
3. Inject it where needed

No configuration is required for most concrete classes.

---

## Controller Injection

This is where you will use DI most frequently.

You may inject dependencies into:

* The **controller constructor**
* Individual **controller methods**

```php
namespace App\Http\Controller;

use Strux\Component\Http\Request;
use App\Services\PaymentService;
use Psr\Log\LoggerInterface;

class CheckoutController
{
    // Constructor injection: shared across actions
    public function __construct(
        protected LoggerInterface $logger
    ) {}

    // Method injection: specific to this action
    public function process(Request $request, PaymentService $payment)
    {
        $this->logger->info('Processing payment...');

        $payment->charge($request->input('amount'));

        return $this->json(['status' => 'success']);
    }
}
```

---

## Service Registries

Auto-wiring works well for concrete classes, but sometimes you must explicitly tell the container **how to build a service**.

Examples include:

* Binding an **interface** to an implementation
* Configuring third-party SDKs
* Defining singletons
* Binding simple values

This is done using **Service Registries** located in:

```text
src/Registry/
```

Registries are **auto-discovered** during bootstrapping.

---

## Creating a Service Registry

Create a new registry class:

```php
namespace App\Registry;

use Strux\Bootstrapping\Registry\ServiceRegistry;
use App\Contracts\MailerInterface;
use App\Services\SmtpMailer;
use ThirdParty\Stripe\StripeClient;

class AppServiceRegistry extends ServiceRegistry
{
    public function register(): void
    {
        // 1. Interface binding
        $this->container->bind(
            MailerInterface::class,
            SmtpMailer::class
        );

        // 2. Singleton binding
        $this->container->singleton(StripeClient::class, function () {
            return new StripeClient(getenv('STRIPE_SECRET'));
        });

        // 3. Simple value binding
        $this->container->bind(
            'app.admin_email',
            fn () => 'admin@example.com'
        );
    }
}
```

---

## Binding Types

| Method                            | Description                                      |
| --------------------------------- | ------------------------------------------------ |
| `bind($abstract, $concrete)`      | **Transient** — new instance each time           |
| `singleton($abstract, $concrete)` | **Singleton** — shared for the request lifecycle |

---

## Manual Resolution (The Bridge)

In rare cases (e.g. legacy helpers), DI may not be available.
Strux provides the **ContainerBridge** for manual resolution.

```php
use Strux\Support\ContainerBridge;
use App\Services\Config;

function get_config(string $key)
{
    $config = ContainerBridge::get(Config::class);
    return $config->get($key);
}
```

:::warning Anti-Pattern
Avoid using `ContainerBridge` inside classes.
It hides dependencies and makes testing harder.

**Always prefer constructor or method injection.**
:::

---

## Summary

* Strux uses **auto-wiring by default**
* Controllers support constructor and method injection
* Service Registries handle advanced bindings
* Interfaces, singletons, and values are first-class citizens
* Manual resolution exists—but should be avoided

---

Next, explore:

* **Request Life Cycle** to see where DI happens
* **Controllers** to see injection in practice
* **Service Providers & Middleware** for advanced patterns