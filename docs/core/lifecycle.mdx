---
title: Request Life Cycle
slug: /lifecycle
description: Understanding how Strux handles an HTTP request.
---

# Request Life Cycle

Understanding the **flow of an HTTP request** in Strux is key to mastering the framework.
This document walks through the journey from the user’s browser to the final response.

---

## High-Level Flow

```mermaid
graph TD
    A[User Request] --> B[web/index.php]
    B --> C[Bootstrap::create]
    C --> D[Container & Registries Load]
    D --> E[App::run]
    E --> F[ServerRequestCreator]
    F --> G[Global Middleware Stack]
    G --> H[Route Dispatcher]
    H --> I[Controller Method]
    I --> J[Response Object]
    J --> K[ResponseEmitter]
    K --> L[Output to Browser]
````

---

## 1️⃣ Entry Point (`index.php`)

Every HTTP request begins at:

```text
web/index.php
```

This file is intentionally minimal.
Its sole responsibility is to **bootstrap and run the application**.

```php
use Strux\Foundation\Bootstrap;

// 1. Load Composer
require_once ROOT_PATH . '/vendor/autoload.php';

// 2. Create the Application
$app = Bootstrap::create(ROOT_PATH);

// 3. Run
$app->run();
```

---

## 2️⃣ Bootstrapping

The `Bootstrap::create()` method prepares the framework before handling the request.

During bootstrapping, Strux initializes:

* **Environment Variables**
Loads `.env` using `vlucas/phpdotenv`

* **Dependency Injection Container**
Registers all services

* **Configuration**
Loads settings from `etc/`

* **Registries**
Core and user-defined components

### Registries Loaded

**Core Registries**

* Database
* Authentication
* Views
* Routing

**User Registries**

* Auto-discovered from `src/Registry/*.php`

:::info Dependency Injection
All services are bound to the container during bootstrapping, making them available for automatic injection into controllers and other services.
:::

---

## 3️⃣ The `App::run()` Method

Once bootstrapped, the application enters the HTTP pipeline.

### What Happens Next

1. **Request Creation**
PHP superglobals (`$_GET`, `$_POST`, etc.) are converted into a **PSR-7 `ServerRequest`** object.

2. **Global Middleware Execution**
The request flows through the global middleware stack:

* Sessions
* CSRF protection
* Authentication
* Logging

3. **Route Dispatching**
The `RouteDispatcher`:

* Matches the URL to a route
* Executes route-level middleware (e.g. `#[Authorize]`)
* Instantiates the controller
* Calls the target method

---

## 4️⃣ Controller & Response

Your controller handles business logic and **must return a Response**.

```php
use Strux\Component\Http\Response;

public function index(): Response
{
    // Business logic...
    return new Response(200, [], 'Hello World');
}
```

---

## 5️⃣ Response Emission

Finally, the `ResponseEmitter` converts the PSR-7 `Response` into raw PHP output:

* Sends HTTP headers
* Echoes the response body
* Terminates the request lifecycle

The result is sent back to the user’s browser.

---

## Summary

The Strux request lifecycle is:

1. **Minimal entry point**
2. **Explicit bootstrapping**
3. **PSR-compliant request handling**
4. **Middleware-driven flow**
5. **Controller-based responses**
6. **Clean response emission**

This design keeps Strux **predictable**, **testable**, and **easy to reason about**.

---

Next, explore:

* **Routing** to see how requests are matched
* **Middleware** to intercept requests
* **Controllers** to handle business logic