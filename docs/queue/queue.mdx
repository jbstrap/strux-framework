---
title: Queue System
sidebar_position: 1
description: Database-driven background job processing in Strux.
---

# Queue System

Strux includes a **database-driven queue system** for offloading long-running or non-blocking tasks such as:

- Sending emails
- Processing uploads
- Generating reports
- Syncing external APIs

By delegating this work to background workers, your application remains **fast and responsive**.

---

## Getting Started

### Initialize the Queue Table

Create the table used to store queued jobs:

```bash
php console queue:init
````

This creates a `_jobs` table (or the name defined in `config/queue.php`).

---

## Creating a Job

Generate a job class via the CLI:

```bash
php console new:job SendWelcomeEmailJob
```

### Example Job

```php
namespace App\Jobs;

use App\Core\Queue\Job;
use App\Core\Mail\MailerInterface;
use App\Models\User;

class SendWelcomeEmailJob extends Job
{
    public function __construct(
        protected User $user
    ) {}

    public function handle(MailerInterface $mailer): void
    {
        $mailer->to($this->user->email)
               ->subject('Welcome!')
               ->send('emails/welcome', [
                   'name' => $this->user->firstname
               ]);
    }
}
```

---

## Dispatching Jobs

```php
use App\Jobs\SendWelcomeEmailJob;
use App\Core\Queue\Queue;

$queue = container(Queue::class);

// Dispatch immediately
$queue->push(new SendWelcomeEmailJob($user));

// Dispatch after 5 minutes
$queue->later(300, new SendWelcomeEmailJob($user));
```

---

## Running the Worker

Start the queue worker:

```bash
php console queue:start
```

:::info Production Tip
Use a process manager like **Supervisor**, **systemd**, or **PM2** to keep workers running.
:::

---

## Configuration

Queue configuration lives in `config/queue.php`:

```php
return [
    'queue' => [
        'default' => env('QUEUE_CONNECTION', 'database'),
        'connections' => [
            'database' => [
                'driver' => 'database',
                'table' => '_jobs',
                'queue' => 'default',
                'retry_after' => 90,
            ],
        ],
    ]
];
```

---

## Architecture & Job Lifecycle

**1. Dispatch**
Jobs are serialized and stored in the `_jobs` table.

**2. Polling**
Workers scan for available jobs (`reserved_at IS NULL`).

**3. Locking**
`reserved_at` is set to prevent duplicate processing.

**4. Execution**
The job is deserialized and `handle()` is executed with DI support.

**5. Completion**
Jobs are deleted on success.

**6. Failure Handling**

* `attempts` increments
* Jobs may be retried or moved to `failed_jobs`

---

## Best Practices

* Pass IDs or DTOs, not heavy objects
* Ensure jobs are **idempotent**
* Use dependency injection in `handle()`
* Prefer multiple small jobs over large ones
